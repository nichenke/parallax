{"type":"finding","id":"v3-assumption-hunter-001","title":"Auto-Fix Step Assumes It Can Correctly Identify Trivial Changes","severity":"Critical","phase":{"primary":"design","contributing":"calibrate"},"section":"Step 4: Auto-Fix","issue":"Design specifies auto-fix classifies findings as trivial and applies automatically. Assumes system can reliably distinguish trivial mechanical fixes from semantic changes. Example: broken internal link could be wrong file extension (trivial) or wrong target document (semantic). No validation mechanism beyond undefined conservative criteria.","why_it_matters":"Auto-fixes modify source files and commit changes automatically. Misclassified fix that changes meaning breaks design. If auto-fix runs before human review, user cannot reject bad auto-fixes—they're already applied and committed.","suggestion":"Add validation requirements: (1) Define conservative with concrete examples and exclusion criteria, (2) Require diffs for user approval before application, (3) Add rollback mechanism, (4) Defer auto-fix to post-human-processing."}
{"type":"finding","id":"v3-assumption-hunter-002","title":"Git-Based Iteration Tracking Assumes Design Doc Lives in Git","severity":"Critical","phase":{"primary":"design","contributing":null},"section":"Output Artifacts, Cross-Iteration Finding Tracking","issue":"Design states iteration history tracked by git. Assumes design document being reviewed is git-tracked. If user reviews design doc outside repository (Google Doc exported to markdown, Confluence page, design from different repo), git diff fails. No fallback specified.","why_it_matters":"Requirements state this should be applicable to work contexts. Many teams use Confluence, Notion, or Google Docs for design documents, not git-tracked markdown. If parallax:review only works for git-tracked docs, excludes significant use cases. Cross-iteration tracking depends on git diff—without it, reviewers lose focus prioritization.","suggestion":"Add input validation checking whether design doc is git-tracked. If not: (1) Warn user that cross-iteration diff won't be available, (2) Fall back to file timestamp comparison or manual change notes, (3) Document git requirement as constraint, (4) Implement text-based diff as fallback."}
{"type":"finding","id":"v3-assumption-hunter-003","title":"Stable Finding IDs Assume Section Headings Don't Change","severity":"Critical","phase":{"primary":"design","contributing":null},"section":"Cross-Iteration Finding Tracking","issue":"Design specifies finding IDs as stable hash derived from section + issue content. Assumes design doc section headings remain stable across iterations. If designer refactors UX Flow into User Workflow and State Management between iterations, all findings anchored to UX Flow become orphaned. Hash-based IDs break when input text changes even if semantic content unchanged.","why_it_matters":"Section refactoring is normal during design iteration. Improving document structure shouldn't invalidate finding tracking. If implemented as designed, cross-iteration tracking will produce false negatives (findings marked resolved when section renamed) and false positives (findings marked new when actually rephrased).","suggestion":"Replace text-based hashing with semantic anchoring or LLM-based matching. Options: (1) Store section heading + offset position, fuzzy-match if heading changed, (2) Use LLM to semantically match findings, (3) Hybrid: hash as first pass, LLM disambiguation on miss, (4) Allow manual finding ID assignment for critical findings."}
{"type":"finding","id":"v3-assumption-hunter-005","title":"Async-First Architecture Assumes File System as Single Source of Truth","severity":"Important","phase":{"primary":"design","contributing":"calibrate"},"section":"UX Flow (async-first)","issue":"Design specifies review always writes artifacts to disk as baseline. Assumes all state lives in files under docs/reviews/<topic>/. If user runs review on machine A, processes findings on machine B (different clone), or collaborates with teammate, state diverges. File-based state requires all participants operate on same filesystem or rigorously sync via git. No synchronization mechanism specified.","why_it_matters":"Requirements emphasize applicable to work contexts and CLAUDE.md notes this repo may be worked on from multiple machines. File-based state doesn't handle distributed workflows without additional tooling. If two users process findings in parallel, last write wins—earlier dispositions silently lost.","suggestion":"Either (1) Document single-user, single-machine constraint explicitly as MVP limitation, (2) Add conflict detection (check if summary.md has uncommitted changes), (3) Require git commit after each disposition batch, (4) Evaluate external state management."}
